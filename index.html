<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>BoxTipping</title>
<style>
  body { margin:0; overflow:hidden; font-family:sans-serif; background:#222; color:white; }
  canvas { background:#111; display:block; margin:0 auto; }
  #restartBtn {
    position:absolute; left:50%; top:50%; transform:translate(-50%, -50%);
    padding:15px 30px; font-size:20px; display:none; cursor:pointer;
  }
  #info { position:absolute; top:10px; left:10px; font-size:18px; }
</style>
</head>
<body>

<canvas id="gameCanvas" width="400" height="700"></canvas>
<div id="info">Score: 0 | Lives: 3 | Level: 1</div>
<button id="restartBtn">Restart</button>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const info = document.getElementById("info");
const restartBtn = document.getElementById("restartBtn");

// --- Spielvariablen ---
let score = 0;
let lives = 3;
let level = 1;
let payUnlocked = false;
let gameOver = false;

let player = {x: canvas.width/2 - 25, y: canvas.height - 120, size:50};
let bullets = [];
let powerups = [];
let enemies = [];

// --- Gegnerklasse ---
class Enemy {
    constructor(){
        this.size = 40;
        this.reset();
    }
    reset(){
        this.x = Math.random()*(canvas.width-this.size);
        this.y = -Math.random()*400-40;
        this.speed = 2 + level*0.5;
    }
    update(){
        this.y += this.speed;
        if(this.y > canvas.height) {
            this.reset();
            lives--;
        }
    }
    draw(){
        ctx.fillStyle = "red";
        ctx.fillRect(this.x,this.y,this.size,this.size);
    }
}

// --- Gegner initialisieren ---
for(let i=0;i<5;i++) enemies.push(new Enemy());

// --- Restart-Button ---
// --- Restart Button ---
restartBtn.addEventListener("click", () => {
    lives = 3;  // Leben zurücksetzen
    player.x = canvas.width/2 - player.size/2;  // Spielerposition zurücksetzen
    player.y = canvas.height - 120;

    bullets = [];
    powerups = [];

    enemies.forEach(e => {
        if(typeof e.reset === "function") e.reset();
        else { e.x = Math.random()*(canvas.width-40); e.y = -Math.random()*400-40; }
    });

    gameOver = false;           // GameOver zurücksetzen
    restartBtn.style.display = "none";

    // Info aktualisieren
    if(info) info.textContent = `Score: ${Math.floor(score)} | Lives: ${lives} | Level: ${level}`;
});

// --- GameOver Check ---
function checkGameOver() {
    if(lives <= 0 && !gameOver){
        gameOver = true;
        restartBtn.style.display = "block";
    }
}

// --- Im Game-Loop unbedingt aufrufen ---
function gameLoop() {
    // Zeichne Hintergrund, Spieler, Gegner etc.

    if(!gameOver) {
        // Bewegungs-/Kollisionslogik nur, wenn nicht GameOver
        enemies.forEach(e => e.update());
        bullets.forEach(b => b.update());
        // weitere Logik...
    }

    checkGameOver();  // Button anzeigen, wenn nötig

    requestAnimationFrame(gameLoop);  // Loop läuft immer weiter
});

// --- Info aktualisieren ---
function updateInfo(){
    info.textContent = `Score: ${Math.floor(score)} | Lives: ${lives} | Level: ${level}`;
}

// --- GameOver prüfen ---
function checkGameOver(){
    if(lives <= 0 && !gameOver){
        gameOver = true;
        restartBtn.style.display = "block";
    }
}

// --- Spieler zeichnen ---
function drawPlayer(){
    ctx.fillStyle = "blue";
    ctx.fillRect(player.x, player.y, player.size, player.size);
}

// --- Game-Loop ---
function gameLoop(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Hintergrund animieren
    ctx.fillStyle = "rgba(50,50,50,0.2)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    drawPlayer();

    enemies.forEach(e=>{
        if(!gameOver) e.update();
        e.draw();
    });

    // GameOver prüfen
    checkGameOver();

    updateInfo();
    requestAnimationFrame(gameLoop);
}

// --- Start ---
gameLoop();
</script>

</body>
</html>
